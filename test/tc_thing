#! ruby
require 'stringio'
require 'test/unit'
require 'such/thing'
# Clear PARAMETERS of any defaults
Such::Thing::PARAMETERS.clear

###########################
### Main Parent Classes ###
###########################

class ParentClass
  attr_reader :done, :added, :signals

  # ParentClass takes no arguments.
  def initialize
    @done = []
    @added = []
    @signals = []
  end

  # Has some method "does"
  def does(x)
    @done.push(x)
  end

  # Supports "add".
  def add(*stuff)
    @added.push(*stuff)
  end

  # And has some way to signal_connect.
  def signal_connect(string)
    @signals.push(string)
  end
end

class OneClass < ParentClass
  attr_reader :one
  alias :v :one

  # OneClass has arity one.
  def initialize(one)
    super()
    @one = one
  end
end

class ManyClass < ParentClass
  attr_reader :many
  alias :v :many

  # ManyClass can take my arguments
  def initialize(*many)
    super()
    @many = many
  end
end

#########################
### Test Such Classes ###
#########################

# arity 0
class SubClass < ParentClass
  include Such::Thing
end

# arity 1
class OneSubClass < OneClass
  include Such::Thing
end

# arity -1
class ManySubClass < ManyClass
  include Such::Thing
end

class TestThing < Test::Unit::TestCase
  def self.capture_stderr
    out = StringIO.new
    $stderr = out
    yield
    return out.string
  ensure
    $stderr = STDERR
  end

  def test_parameters
    # I Haz PARAMETERS
    assert_nothing_raised() do
      p = Such::Thing::PARAMETERS
      assert_equal(p.class, Hash)
    end
  end

  def test_configure
    assert_nothing_raised() do
      p = Such::Thing::PARAMETERS
      p.clear
      Such::Thing.configure(
        a: 'A',
        b: 'B',
        c: 'C',
      )
      assert_equal({a:'A',b:'B',c:'C'}, p)
      p.clear
    end
  end

  def test_trace_method
    assert_nothing_raised() do
      a = []; m = :puts; v = [1,2,3]
      out = TestThing.capture_stderr{ Such::Thing.trace_method(a,m,v) }
      assert_equal("Array#puts(1,2,3)\n", out)
    end
  end

  def test_trace_signal
    assert_nothing_raised() do
      a = {}; s = 'Keys'
      out = TestThing.capture_stderr{ Such::Thing.trace_signal(a,s) }
      assert_equal("Hash links Keys\n", out)
    end
  end

  def test_do_symbol
    assert_nothing_raised() do
      p = Such::Thing::PARAMETERS
      p.clear

      p[:A]=[1,2,3]; p[:a]='a'; p[:a!]=[:A,:a,'a']

      x = ['b','c']
      out = TestThing.capture_stderr{ Such::Thing.do_symbol(:a, x) }
      assert_equal('', out)
      assert_equal(['a','b','c'], x)

      x = ['b','c']
      out = TestThing.capture_stderr{ Such::Thing.do_symbol(:A, x) }
      assert_equal('', out)
      assert_equal([[1,2,3],'b','c'], x)

      x = ['b','c']
      out = TestThing.capture_stderr{ Such::Thing.do_symbol(:a!, x) }
      assert_equal('', out)
      assert_equal([:A,:a,'a','b','c'], x)

      x = ['b','c']
      out = TestThing.capture_stderr{ Such::Thing.do_symbol(:k, x) }
      assert_match(/^Warning:/, out)
      assert_equal(['b','c'], x)

      # When :symbol! is not set, it does *[:SYMBOL, :symbol].
      x = ['b','c']
      out = TestThing.capture_stderr{ Such::Thing.do_symbol(:b!, x) }
      assert_equal('', out)
      assert_equal([:B,:b,'b','c'], x)

      p.clear
    end
  end

  def test_do_parameters
    assert_nothing_raised() do
      p = Such::Thing::PARAMETERS
      p.clear
      p[:A]=[1,2,3]; p[:a]={a:'a'}; p[:a!]=[:A,:a,'a']

      c, a, m, s = Such::Thing.do_parameters([:a!])
      assert_equal([nil, [1,2,3],  {a:'a'}, ['a']], [c,a,m,s])

      b = ParentClass.new
      c, a, m, s = Such::Thing.do_parameters([b, :a!])
      assert_equal([b, [1,2,3],  {a:'a'}, ['a']], [c,a,m,s])

      p.clear
    end
  end

  def test_into
    # Via class method
    assert_nothing_raised() do
      container = SubClass.new
      item = SubClass.new
      # container is empty
      assert_equal([], container.added)
      out = TestThing.capture_stderr{ Such::Thing.into(item, container) }
      assert_equal('', out)
      # container now has item
      assert_equal([item], container.added)
      # just gives warning if no container is given.
      out = TestThing.capture_stderr{ Such::Thing.into(item) }
      assert_match(/^Warning:/, out)
    end
    # Via new
    assert_nothing_raised() do
      container = SubClass.new
      # item should put itself into container
      item = SubClass.new container
      assert_equal([item], container.added)
    end
  end

  def test_do_method
    assert_nothing_raised() do
      a = []
      Such::Thing.do_method(a, :push, 1)
      assert_equal([1], a)
      Such::Thing.do_method(a, :clear) # checks that raises no errors
      assert_equal([], a)
      b = {}
      Such::Thing.do_method(b, :[]=, :a, 'A')
      assert_equal({a:'A'}, b)
      Such::Thing.do_method(b, :clear)
      assert_equal({}, b)
      out = TestThing.capture_stderr{
        Such::Thing.do_method(b, :[]=, [:a,'A'], [:b,'B'], [:c,'C'])
      }
      assert_match(/^Warning:/, out) # warns that arity was not one, poor heuristics.
      assert_equal({a:'A',b:'B',c:'C'}, b)
    end
  end

  def test_do_methods
    assert_nothing_raised() do
      container = SubClass.new
      item = SubClass.new
      Such::Thing.do_methods(item, {does:'OK'}, container)
      assert_equal(['OK'], item.done)
      assert_equal([item], container.added)
    end
  end

  def test_do_links
    assert_nothing_raised() do
      item = SubClass.new
      wontcallanyways = true
      Such::Thing.do_links(item, ['a','b','c'], wontcallanyways)
      assert_equal(['a','b','c'], item.signals)
    end
  end

  def test_new_arity
    # Nothing raised with correct arity.
    assert_nothing_raised() do
      # Blank takes nothing
      SubClass.new
      SubClass.new []
      # One takes exactly one
      OneSubClass.new [1]
      # Many takes any
      ManySubClass.new
      ManySubClass.new []
      ManySubClass.new [1]
      ManySubClass.new [1,2,3]
    end

    # ArgumentError raised with incorrect arity
    assert_raise(ArgumentError) do
      SubClass.new [1]
    end
    assert_raise(ArgumentError) do
      OneSubClass.new
    end
    assert_raise(ArgumentError) do
      OneSubClass.new []
    end
    assert_raise(ArgumentError) do
      OneSubClass.new [1,2]
    end
  end

  def test_initialize
    assert_nothing_raised() do
      blank = SubClass.new
      assert_equal(blank.done, [])
      blank.does(1); blank.does(2); blank.does(4)
      assert_equal(blank.done, [1,2,4])
    end
    assert_nothing_raised() do
      one = OneSubClass.new ['A']
      assert_equal(one.v, 'A')
    end
    assert_nothing_raised() do
      many0 = ManySubClass.new
      many1 = ManySubClass.new ['A']
      many3 = ManySubClass.new ['x','y','z']
      many  = ManySubClass.new ['A'],['x','y','z']
      assert_equal(many0.v, [])
      assert_equal(many1.v, ['A'])
      assert_equal(many3.v, ['x','y','z'])
      assert_equal(many.v,  ['A', 'x','y','z'])
    end
  end

  def test_methods
    assert_nothing_raised() do
      blank = SubClass.new does: 1
      one   = OneSubClass.new ['A'], does: 2
      many  = ManySubClass.new({does: 3}, ['x','y','z'])

      assert_equal([1], blank.done)

      assert_equal([2], one.done)
      assert_equal('A', one.v)

      assert_equal([3], many.done)
      assert_equal(['x','y','z'], many.v)

      # Quick overide test...
      blank2 = SubClass.new({does: 1}, {does: 'a'})
      # Only does('a') happens:
      assert_equal(['a'], blank2.done)
    end
  end

  def test_link
    assert_nothing_raised() do
      blank = SubClass.new 'event'
      blank2 = SubClass.new('event1', 'event2'){ true }
      assert_equal(['event'], blank.signals)
      assert_equal(['event1', 'event2'], blank2.signals)
    end
  end

  def test_translation
    assert_nothing_raised() do
      p = Such::Thing::PARAMETERS
      p[:A] = [1,2,3]
      p[:a] = {does: 'X'}
      p[:a!] = [:A,:a,'x']
      many = ManySubClass.new(:a!){ true }
      assert_equal([1,2,3], many.v)
      assert_equal(['X'], many.done)
      assert_equal(['x'], many.signals)
      p.clear # restore to clear
    end
  end
end
